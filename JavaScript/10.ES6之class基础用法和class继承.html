<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body></body>
</html>
<script>
  //一.class的基础用法
  // 1.ES6引入Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。
  class Point {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }

    toString() {
      console.log(this.name + this.age);
    }
  }
  // ES5实现ES6同样的效果
  function Point(name, age) {
    this.name = name;
    this.age = age;
  }
  Point.prototype.toString = function() {
    console.log(this.name + this.aget);
  };
  // ES6类的constructor(构造方法)函数相当于ES5的构造函数
  //定义“类”的方法的时候，前面不需要加上function这个关键字
  //类的所有方法都定义在类的prototype属性上面。
  //类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致(可以枚举的)。
  // ES6
  class Point {
    constructor(x, y) {
      // ...
    }

    toString() {
      // ...
    }
  }

  Object.keys(Point.prototype);
  //[]   不可枚举的
  ES6;
  var Point = function(x, y) {
    // ...
  };

  Point.prototype.toString = function() {
    // ...
  };

  Object.keys(Point.prototype);
  // ["toString"]   可以枚举的

  // 2.constructor 方法
  // constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有
  // constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
  // 3.类的实例对象
  // 生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令
  class Point {
    // ...
  }
  // 报错
  var point = Point(2, 3);
  // 正确
  var point = new Point(2, 3);
  //4.Class 表达式
  const MyChild = class Child {
    toString() {
      console.log(Child.name); //name属性总是返回紧跟在class关键字后面的类名。
    }
  };
  //类的名字是MyChild而不是Child,Child只在Class内部代码可用
  let mychild = new MyChild();
  mychild.toString(); // Child
  //如果函数内部用不到Child,也可以省略
  const MyChild = class {
    // ...
  };
  // 5.Class 的静态方法
  // 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，
  // 加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
  class Foo {
    static className() {
      console.log("heyushuo");
    }
  }
  Foo.className(); //heyushuo 不能通过实例调用会报错
  // 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。
  class Foo {
    static bar() {
      this.baz();
    }
    static baz() {
      console.log("hello");
    }
    baz() {
      console.log("world");
    }
  }

  Foo.bar(); // hello
  // 1.静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。
  // 2.静态方法可以与非静态方法重名。

  // 父类的静态方法，可以被子类继承。
  class Foo {
    static classMethod() {
      return "hello";
    }
  }
  class Bar extends Foo {}
  Bar.classMethod(); // 'hello'

  // 二.类的继承
  // Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
</script>
