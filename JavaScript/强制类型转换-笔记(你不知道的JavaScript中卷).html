<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Document</title>
</head>

<body></body>

</html>
<script>
  // 强制类型转换
  // 1.值类型转换
  // 将值从一种类型转换为另一种类型通常称为类型转换, 在 JavaScript 中通常称为强制类型转换,本书为了跟好理解把强制类型转换
  //分为两种“隐式强制类型转换”和“显式强制类型转换”
  // 例如:
  var a = 42;
  var b = a + ""; // "42" 隐式强制类型转换
  var c = String(a); //"42" 显式强制类型转换

  // 2.抽象值操作
  //  ES5 规范第 9 节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转
  // 换规则。(ToString、ToNumber 和 ToBoolean)
  //  2.1 ToString
  //   抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。
  var num = 666;
  //极大数字
  var infinityNum = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
  var obj = {
    name: 'kebi',
    age: 36
  }
  var arr = [1, 2, 3];
  //null和undefined没有toString() 方法
  String(null) //"null"
  String(undefined) //"undefined"
  String(true) //"true"
  num.toString(); //"666"
  obj.toString(); //"[object Object]"
  infinityNum.toString(); // "1.07e21"
  arr.toString(); //1,2,3 数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 "," 连接起来
  // 2.2 ToNumber
  //   有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了
  // 抽象操作 ToNumber。
  // 以下是Number处理基础类型的返回值
  Number(false) //0
  Number(null) //0
  Number(true) //true
  Number(undefined) //NAN
  //   但是对于对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型
  // 值，则再遵循以上规则将其强制转换为数字。

  // 为了将值转换为相应的基本类型值， 会首先检查该值是否有 valueOf() 方法。
  // 如果有并且返回基本类型值， 就使用该值进行强制类型转换。 如果没有就使用 toString()
  // 的返回值（ 如果存在） 来进行强制类型转换。
  // 如果 valueOf() 和 toString() 均不返回基本类型值， 会产生 TypeError 错误。

  // 注从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没
  // 有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。

  var a = {
    valueOf: function () {
      return "42";
    }
  };
  var b = {
    toString: function () {
      return "42";
    }
  };
  var c = [4, 2];
  c.toString = function () {
    return this.join(""); // "42"
  };
  Number(a); // 42
  Number(b); // 42
  Number(c); // 42
  Number(""); // 0
  Number([]); // 0
  Number(["abc"]); // NaN


  // 2.3ToBoolean
  //   JavaScript 中的值可以分为以下两类：
  // (1) 可以被强制类型转换为 false 的值
  // (2) 其他（被强制类型转换为 true 的值）
  // 以下这些是假值：
  Boolean(undefined)
  Boolean(null)
  Boolean(false)
  Boolean(+0)
  Boolean(-0)
  Boolean(NaN)
  Boolean("")
  // 除了上边的以外都是真值
  // 综上也可以看出以下所有值都是true
  Boolean([])
  Boolean({})

  // 3.显式强制类型转换
  // 3.1字符串和数字之间的显式转换
  //第一种方式
  var a = 42;
  var b = String(a);
  var c = "3.14";
  var d = Number(c);
  b; // "42"
  d; // 3.14
  // 第二种方式
  var a = 42;
  var b = a.toString();
  var c = "3.14";
  var d = +c;
  b; // "42"
  d; // 3.14
  // a.toString()是显式，不过其中涉及隐式转换。因为
  // toString() 对 42 这样的基本类型值不适用，所以 JavaScript 引擎会自动为 42 创建一个封
  // 装对象，然后对该对象调用 toString()。

  // +c 是 + 运算符的一元（ unary） 形式（ 即只有一个操作数）。 + 运算符显式地将 c 转
  // 换为数字， 而非数字加法运算
  // 3.1.1  日期显式转换为数字
  var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT"); +
  +d; // 1408369986000
  // 获取时间戳
  var timestamp = +new Date();
  // 一些常用的转换为时间戳
  new Date().getTime();
  Date.now()
  //   我们不建议对日期类型使用强制类型转换，应该使用 Date.now() 来获得当前的时间戳，使
  // 用 new Date(..).getTime() 来获得指定时间的时间戳。

  // 3.2显式解析数字字符串
  // 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但是解析和强制类型转换两者有明显的区别

  var a = "42";
  var b = "42px";
  Number(a); // 42
  parseInt(a); // 42
  Number(b); // NaN
  parseInt(b); // 42
  //   解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停
  // 止。而转换不允许出现非数字字符，否则会失败并返回 NaN

  // parseInt(..) 针对的是字符串值，非字符串参数会首先被强制类型转换为字符串，应该避免向 parseInt(..) 传递非字符串参数。
  // 3.3显式转换为布尔值
  // 从非布尔值强制类型转换为布尔值的情况
  var a = "0";
  var b = [];
  var c = {};
  var d = "";
  var e = 0;
  var f = null;
  var g;
  Boolean(a); // true
  Boolean(b); // true
  Boolean(c); // true
  Boolean(d); // false
  Boolean(e); // false
  Boolean(f); // false
  Boolean(g); // false
  // 虽然 Boolean(..) 是显式的，但并不常用，常用如下写法
  var a = "0";
  var b = [];
  var c = {};
  var d = "";
  var e = 0;
  var f = null;
  var g;
  !!a; // true
  !!b; // true
  !!c; // true
  !!d; // false
  !!e; // false
  !!f; // false
  !!g; // false
  //   在 if(..).. 这样的布尔值上下文中，如果没有使用 Boolean(..) 和 !!，就会自动隐式地进
  // 行 ToBoolean 转换。建议使用 Boolean(..) 和 !! 来进行显式转换以便让代码更清晰易读。

  // 4.隐式强制类型转换
  // 隐式强制类型转换的作用是减少冗余，让代码更简洁,同时会让代码变得晦涩难懂
  // 4.1字符串和数字之间的隐式强制类型转换
</script>