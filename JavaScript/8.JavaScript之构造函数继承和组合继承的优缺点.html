<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

</body>

</html>
<script>
  //一.构造函数继承
  //1. 构造函数继承的基本思路是在子类型的构造函数中,调用要继承的构造函数,具体实现如下:
  function Parent() {
    this.name = ["heyushuo", "kebi"];
  }

  function Child() {
    Parent.call(this);
    // 或者 Parent.apply(this);
  }

  var Person1 = new Child();
  Person1.name.push("kuli");
  console.log(Person1.name); //["heyushuo", "kebi","kuli"];
  var Person2 = new Child();
  console.log(Person2.name); //["heyushuo", "kebi"];
  // 通过上边的两个打印,Child的两个实例继承的name属性不会互相影响
  // 因为,创建Child实例的环境下调用Parent构造函数,这样可以使得每个实例都会具有自己的name属性,所以两个不会互相影响
  // 2. 优点(可以传递参数,和上边)
  function Parent(name) {
    this.name = name;
  }

  function Child() {
    Parent.call(this, "heyushuo");
    //或者Parent.apply(this, ["heyushuo"]);
  }
  var Person = new Child();
  console.log(Person.name); //heyushuo

  // 需要注意的:为了确保Parent构造函数不会重写子类型的属性,需要在Parent.call(this);之后在定义子类型中的属性
  //3.构造函数的缺点
  //因为方法和属性只能写在构造函数中,因此不能实现函数复用
  // 只能继承父类的实例属性和方法，不能继承原型属性/方法 (原型中定义的方法和属性对于子类是不可见的)

  //二.组合继承(原型链和构造函数组合式继承)
</script>